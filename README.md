# 스프링 입문 from [Inflearn](https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%9E%85%EB%AC%B8-%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8/)

## 프로젝트생성하기 ([링크](https://start.spring.io/))
---
### gradle thymeleaf

- 프로젝트 옵션
    - Project: Gradle Project
    - Spring Boot: 2.3.xLanguage: Java
    - Packaging: Jar
    - Java: 11
- Project Metadata
    - groupId: 원하는 이름
    - artifactId: 원하는 이름
    - Dependencies: Spring Web, Thymeleaf

<br>
⚡ Gradle은 의존관계가 있는 라이브러리를 함께 다운로드 한다<br>
⚡ Spring Web은 톰캣(웹서버)를 내장하고 있는 라이브러리<br>
⚡ thymeleaf는 View를 위한 템플릿 엔진
<br>
<br>

MVC : MVC패턴으로 템플릿을 가지고 결과물을 만들어서 웹브라우저로 내려줌
API : 객체를 JSON모양으로 변환해서 웹브라우저로 내려줌

JPA : sql 없이 객체를 바로 DB에 저장하는 기술?
스프링 데이터 JPA : JPA를 스프링으로 감싼 기술

<br>

---
## MVC와 템플릿 엔진
---

<br>

### 예제1. getMethod로 값을 받아 웹페이지에 표시하기
`HelloController.java`
```java
@Controller
public class HelloController {
    @GetMapping("hello-mvc")
    public String helloMvc(@RequestParam("name") String name, Model model) {
        model.addAttribute("name", name);
        
        return "hello-template";
    }
}
```
- 동작설명
  - ⚡ `@GetMapping("hello-mvc")` : http://localhost:8080/hello-mvc로 연결 할 때 동작<br>
  - ⚡ `@RequestParam("name") String name` : http://localhost:8080/hello-mvc?name=[원하는 값], [원하는 값]에 해당하는 Value를 String name에 저장한다.<br>
  - ⚡ `model.addAttribute("name", name)` : `model.addAtrribute(Key,Value)`의 구조로 Key값은 `"name"`, Value 값은 `RequestParam`으로 받은 `String name`의 값<br>
  - ⚡ `return "hello-template"` : `hello-template.html` 파일에 model 객체를 넘긴다.

<br>

`hello-template.html`
```html
<!DOCTYPE HTML>
<html xmlns="http://www.thymeleaf.org">
    <body>
        <p th:text="'hello. '+${name}"> 안녕하세요. 손님</p>
    </body>
</html>
```
 ⚡ `<p th:text="'hello. '+${name}">` 넘겨받은 `model` 객체에서 `key`값이 `name`인 `value`를 출력

<br>

### 예제2. API 방식
#### 1. `@ResponseBody 문자 반환`
```java
@Controller
public class HelloController {
    @GetMapping("hello-string")
    @ResponseBody 
    public String helloString(@RequestParam("name") String name) {
        return "hello " + name;
    }
}
```
⚡ `@RespnseBody`를 사용하면 ViewResolver를 사용하지 않음, 대신에 HTTP의 BODY에 문자 내용을 직접 반환<br> (HTML BODY TAG를 말하는 것이 아님) HTML 파일을 작성하지 않아도 됨. (HttpMessageConverter)

<br>

#### 2. JSON 방식구현, 요즘에는 XML보다 JSON 반환이 거의 기본
```java

public class HelloController {

    //Hello 라는 객체 생성
    static class Hello {
        private String name;

        // getter & setter : Property 방식이라고 부름
        public String getName() {
            return this.name;
        }
        public void setName(String name) {
            this.name = name;
        }

    }

    @GetMapping("hello-api")
    @ResponseBody // Body에 내용을 출력하겠다(HttpMessageConverter)
    public Hello helloApi(@RequestParam("name") String name) {
        Hello hello = new Hello();
        hello.setName(name);
        return hello; // ❔ 객체를 리턴하면 HttpMessageConverter -> JsonConverter 동작함
                      // ❔ 스프링에서는 Jackson2 라이브러리 사용
    }
}

```

<br>

---
## H2 DB [(설치)](https://www.h2database.com/html/main.html)
---
###  H2 DB 접근 및 JDBC URL 설정 
---
<br>
⭐ 파일로 접근하게되면 `Application`과 `WebConsole`이 동시에 접근이 안될 수 있어 파일 충돌 위험이 있기 때문에 파일로 직접 접근하지말고 local호스트로 접근하자.<br> 

`ex) http://localhost:8082/login.jsp?jsessionid=c8b09f74dd7e0f6dc5ab99bad8e4ba3c`
<br>
<br>
⭐마찬가지로 h2에 접근하게되면 JDBC URL을 적어서 연결 할 수 있는데, 아래와 같이 localhost로 접근하자.  
`jdbc:h2:tcp://localhost/~/db명`
<br>
<br>

H2 member 테이블 만들기 `query`

```sql
create table member
(
    /* db가 자동으로 id 값을 만들어줌 */
    id bigint generated by default as identity,
    name varchar(255),
    primary key (id)
);
```
<br>

member 테이블에 회원 추가해보기
```sql
insert into member(name) values('muice')
```
<br>

---
### 프로젝트와 DB 연결하기
---
<br>
스프링 부트 데이트베이스 연결 설정<br>

`resources/application.properties` 에 내용 추가
```
spring.datasource.url=jdbc:h2:tcp://localhost/~/test
spring.datasource.driver-class-name = org.h2.Driver
spring.datasource.username = 유저네임
<!-- 비밀번호를 설정한 경우 -->
spring.datasource.password = 비밀번호
```
<br>

<details>
<summary> 순수 JDBC - DB 연결을 위한 JdbcRepository 구현체 구현</summary>
<div markdown="1">

```java
package spring.study.repository;

import spring.study.domain.Member;
import org.springframework.jdbc.datasource.DataSourceUtils;
import javax.sql.DataSource;
import java.sql.*;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

//MemberRepository 인터페이스를 사용
public class JdbcMemberRepository implements MemberRepository {

    // DB에 연결하기
    private final DataSource dataSource;

    public JdbcMemberRepository(DataSource dataSource) {
        this.dataSource = dataSource;
    }

    @Override
    public Member save(Member member) {
        String sql = "insert into member(name) values(?)";
        Connection conn = null;

        // statement를 상속받는 인터페이스로 SQL구문을 실행시키는 기능을 갖는 객체
        // Connection 객체의 prepareStatement(String query)를 통해 생성된다.
        PreparedStatement pstmt = null;

        // resultSet(rs) 내부에는 데이터를 읽을 수 있는 커서가 있습니다. 이게 처음에는 데이터를 읽을 수 없는 가장 앞쪽에 있어서 한번은
        // rs.next()를 호출해주어야 그 다음부터 데이터를 읽을 수 있게 됨.
        ResultSet rs = null;

        try {
            conn = getConnection();
            // db에서 id(key)값을 받아옴
            pstmt = conn.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);

            pstmt.setString(1, member.getName());

            // DB에 쿼리를 보냄
            pstmt.executeUpdate();

            rs = pstmt.getGeneratedKeys();
            if (rs.next()) {
                member.setId(rs.getLong(1));
            } else {
                throw new SQLException("id 조회 실패");
            }
            return member;
        } catch (Exception e) {
            throw new IllegalStateException(e);
        } finally {
            // ⭐ 자원들을 Release해줘야함. 안하면 큰일남
            close(conn, pstmt, rs);
        }
    }

    @Override
    public Optional<Member> findById(Long id) {
        String sql = "select * from member where id = ?";
        Connection conn = null;
        PreparedStatement pstmt = null;
        ResultSet rs = null;
        try {
            conn = getConnection();
            pstmt = conn.prepareStatement(sql);
            pstmt.setLong(1, id);
            rs = pstmt.executeQuery();
            if (rs.next()) {
                Member member = new Member();
                member.setId(rs.getLong("id"));
                member.setName(rs.getString("name"));
                return Optional.of(member);
            } else {
                return Optional.empty();
            }
        } catch (Exception e) {
            throw new IllegalStateException(e);
        } finally {
            close(conn, pstmt, rs);
        }
    }

    @Override
    public List<Member> findAll() {
        String sql = "select * from member";
        Connection conn = null;
        PreparedStatement pstmt = null;
        ResultSet rs = null;
        try {
            conn = getConnection();
            pstmt = conn.prepareStatement(sql);
            rs = pstmt.executeQuery();
            // 모든 member를 받아와 members Array에 저장하고 반환함
            List<Member> members = new ArrayList<>();
            while (rs.next()) {
                Member member = new Member();
                member.setId(rs.getLong("id"));
                member.setName(rs.getString("name"));
                members.add(member);
            }
            return members;
        } catch (Exception e) {
            throw new IllegalStateException(e);
        } finally {
            close(conn, pstmt, rs);
        }
    }

    @Override
    public Optional<Member> findByName(String name) {
        String sql = "select * from member where name = ?";
        Connection conn = null;
        PreparedStatement pstmt = null;
        ResultSet rs = null;
        try {
            conn = getConnection();
            pstmt = conn.prepareStatement(sql);
            pstmt.setString(1, name);
            rs = pstmt.executeQuery();
            if (rs.next()) {
                Member member = new Member();
                member.setId(rs.getLong("id"));
                member.setName(rs.getString("name"));
                return Optional.of(member);
            }
            return Optional.empty();
        } catch (Exception e) {
            throw new IllegalStateException(e);
        } finally {
            close(conn, pstmt, rs);
        }
    }

    private Connection getConnection() {
        return DataSourceUtils.getConnection(dataSource);
    }
    // 자원들을 Release 해주는 함수
    private void close(Connection conn, PreparedStatement pstmt, ResultSet rs) {
        try {
            if (rs != null) {
                rs.close();
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        try {
            if (pstmt != null) {
                pstmt.close();
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
        try {
            if (conn != null) {
                close(conn);
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }
    }
    //Connection을 닫아주는 함수
    private void close(Connection conn) throws SQLException {
        DataSourceUtils.releaseConnection(conn, dataSource);
    }

}
```

</div>
</details>

<br>

<details>
<summary> 스프링 JDBC로 구현</summary>
<div markdown="1">

``` java
package spring.study.repository;

import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.Optional;

import javax.sql.DataSource;

import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.simple.SimpleJdbcInsert;

import spring.study.domain.Member;

public class JdbcTemplateMemberRepository implements MemberRepository {

    // 스프링 Jdbc
    private final JdbcTemplate jdbcTemplate;

    // ⭐ 생성자가 하나이면 @Autowirde 생략 가능
    public JdbcTemplateMemberRepository(DataSource dataSource) {
        jdbcTemplate = new JdbcTemplate(dataSource);
    }

    @Override
    public Member save(Member member) {
        SimpleJdbcInsert jdbcInsert = new SimpleJdbcInsert(jdbcTemplate);
        jdbcInsert.withTableName("member").usingGeneratedKeyColumns("id");

        Map<String, Object> parameters = new HashMap<>();
        parameters.put("name", member.getName());

        Number key = jdbcInsert.executeAndReturnKey(new MapSqlParameterSource(parameters));
        member.setId(key.longValue());
        return member;
    }

    @Override
    public Optional<Member> findById(Long id) {

        List<Member> result = jdbcTemplate.query("select * from member where id = ?", memberRowMapper(), id);
        return result.stream().findAny();
    }

    @Override
    public List<Member> findAll() {
        return jdbcTemplate.query("select * from member", memberRowMapper());
    }

    @Override
    public Optional<Member> findByName(String name) {
        List<Member> result = jdbcTemplate.query("select * from member where name = ?", memberRowMapper(), name);
        return result.stream().findAny();
    }

    /*
     * `RowMapper`를 사용하면, 원하는 형태의 결과값을 반환할 수 있다. SELECT로 나온 여러개의 값을 반환할 수 있을 뿐만 아니라,
     * 사용자가 원하는 형태로도 얼마든지 받을 수 있다.
     * 
     */

    // `RowMapper의 `mapRow(ResultSet rs, int count)` 메소드
    /*
     * ResultSet에 값을 담아와서 User 객체에 저장한다. 그리고 그것을 count만큼 반복한다는 뜻이다.
     */

    private RowMapper<Member> memberRowMapper() {

        // return new RowMapper<Member>() {
        // @Override
        // public Member mapRow(ResultSet rs, int rowNum) throws SQLException {
        // Member member = new Member();
        // member.setId(rs.getLong("id"));
        // member.setName(rs.getString("name"));
        // return member;
        // }
        // };

        // 위의 코드를 람다로 변경 ( ⚡ VSC 단축키 `ctrl` + `.`)
        return (rs, rowNum) -> {
            Member member = new Member();
            member.setId(rs.getLong("id"));
            member.setName(rs.getString("name"));
            return member;
        };
    }

}

```

</div>
</details>

- 반복 코드를 대부분 제거해주기 때문에 순수 JDBC보다 간결

<br>

<details>
<summary>⭐ JPA로 구현 </summary>
<div markdown="1">

`build.gradle` 파일에 JPA, H2 DB 관련 라이브러리 추가

```gradle
dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-thymeleaf'
    implementation 'org.springframework.boot:spring-boot-starter-web'
    //implementation 'org.springframework.boot:spring-boot-starter-jdbc'
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    runtimeOnly 'com.h2database:h2'
    testImplementation('org.springframework.boot:spring-boot-starter-test') {
        exclude group: 'org.junit.vintage', module: 'junit-vintage-engine'
    }
}
```

`resources/application.propertie`에 JPA 설정 추가
```property
spring.datasource.url=jdbc:h2:tcp://localhost/~/test
spring.datasource.driver-class-name=org.h2.Driver
spring.datasource.username=sa
spring.jpa.show-sql=true
spring.jpa.hibernate.ddl-auto=none

⚡ show-sql : JPA가 생성하는 SQL을 출력한다.
⚡ ddl-auto : JPA는 테이블을 자동으로 생성하는 기능을 제공하는데 none 를 사용하면 해당 기능을 끈다.
⚡ create 를 사용하면 엔티티 정보를 바탕으로 테이블도 직접 생성해준다.
```

`domain.member.java`에 다음 내용 추가

```java
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;

@Entity
public class Member {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    ... 이하내용 동일
```

`service.MemberService.java`에 다음 내용 추가
```java
//⭐ JPA를 사용할 때 데이터를 변경하거나 저장하는 곳에 항상 @Transactional이 있어야한다.
@Transactional
public class MemberService {
    ...
}
```

`SpringConfig.java`에 다음 내용 추가
```java
    private EntityManager em;

    @Autowired
    public SpringConfig(EntityManager em) {
        this.em = em;
    }
    ... 이하내용 동일
```
`JpaMemberRepsitory.java` 파일 생성
```java
package spring.study.repository;

import java.util.List;
import java.util.Optional;

import javax.persistence.EntityManager;

import spring.study.domain.Member;

public class JpaMemberRepository implements MemberRepository {

    // ⭐ EntityManger가 내부적으로 datasource를 들고있으면서 DB와 통신한다.
    private final EntityManager em;

    // EntityManager em을 DI방식으로 주입
    public JpaMemberRepository(EntityManager em) {
        this.em = em;
    }

    @Override
    public Member save(Member member) {
        em.persist(member);
        return member;
    }

    @Override
    public Optional<Member> findById(Long id) {
        Member member = em.find(Member.class, id);
        return Optional.ofNullable(member);
    }

    @Override
    public Optional<Member> findByName(String name) {

        List<Member> result = em.createQuery("select m from Member m where m.name= :name", Member.class)
                .setParameter("name", name).getResultList();
        return result.stream().findAny();
    }

    @Override
    public List<Member> findAll() {
        return em.createQuery("select m from Member m", Member.class).getResultList();
    }
}
```

</div>
</details>

- JPA는 반복 코드는 물론이고, 기본적인 SQL도 직접 만들어 실행해준다.
- JPA를 사용하면 개발 생산성을 크게 높일 수 있다.
- JPA를 사용하면, SQL과 데이터 중심의 설계에서 객체 중심의 설계로 패러다임 전환을 할 수 있다.

<details>
<summary>⭐⭐ 스프링 데이터 JPA로 구현 </summary>
<div markdown="1">

`SpringConfig` 파일을 아래와 같이 수정
```java
@Configuration
public class SpringConfig {

    private EntityManager em;

    private final MemberRepository memberRepository;

    // ⚡ 스프링 데이터 JPA
    @Autowired
    public SpringConfig(MemberRepository memberRepository) {
        this.memberRepository = memberRepository;
    }

    @Bean
    public MemberService memberService() {
        return new MemberService(memberRepository);
    }
}
```
SpringDataJpaMemberRepository.java파일 생성
```java
package spring.study.repository;

import org.springframework.data.jpa.repository.JpaRepository;

import spring.study.domain.Member;

import java.util.Optional;

//⭐ JpaRepository 라이브러리가 save,delete,finbyId 등 기본 CRUD 기능을 제공하기 때문에 구현하지 않아도 됨
//인터페이스로  인터페이스를 상속받을 때는 extends 사용
//자동으로 구현체를 만들어 Bean에 자동 등록해줌
public interface SpringDataJpaMemberRepository extends JpaRepository<Member, Long>, MemberRepository {

    // ⭐ 인터페이스 이름만으로 기능을 구현해서 보여줌.
    // select m from Member m where m.name = ? 방식으로 작동
    @Override
    Optional<Member> findByName(String name);
}

```
</div>
</details>

- JPA만 사용해도 개발 생산성이 많이 증가하지만 여기에 스프링 데이터 JPA를 사용하면 기존의 한계를 넘어 Repository에 구현 클래스 없이 인터페이스 만으로 개발이 가능하다.
- 기본 CRUD 기능, 페이징 기능을 자동 제공해줌.
- JPA 선행지식은 필수 !

<br>

<b> ⭐ 개방-폐쇄 원칙(OCP, Open-Closed Principle)</b><br>

- 스프링 DI를 사용하면 기존 코드를 전혀 손대지 않고, 설정만으로 구현 클래스를 변경 할 수 있다.

Ex ) DB 연결의 변경 (`springConfig.java` 파일)
```java
    @Bean
    public MemberRepository memberRepository() {
        // Memory Repository 사용
         return new MemoryMemberRepository();

        // 순수 JDBC 사용
         return new JdbcMemberRepository(dataSource);

        // 스프링 JDBC 사용
         return new JdbcTemplateMemberRepository(dataSource);

        // JPA 사용
        return new JpaMemberRepository(em);
    }
```

<details>
<summary>springConfig.java 전체 코드</summary>
<div markdown="1">

``` java
package spring.study;

import javax.persistence.EntityManager;
import javax.sql.DataSource;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import spring.study.repository.JdbcMemberRepository;
import spring.study.repository.JdbcTemplateMemberRepository;
import spring.study.repository.JpaMemberRepository;
import spring.study.repository.MemberRepository;
import spring.study.repository.MemoryMemberRepository;
import spring.study.service.MemberService;

@Configuration
public class SpringConfig {

    // @Autowired DataSource dataSource;

    private DataSource dataSource;

    private EntityManager em;

    @Autowired
    public SpringConfig(EntityManager em) {
        this.em = em;
    }

    // ⚡ Jdbc 사용하는 경우 주석해제
    // dataSource를 DI 해줌
    // @Autowired
    // public SpringConfig(DataSource dataSource) {
    // this.dataSource = dataSource;
    // }

    @Bean
    public MemberService memberService() {
        return new MemberService(memberRepository());
    }

    @Bean
    public MemberRepository memberRepository() {
        // Memory Repository 사용
        // return new MemoryMemberRepository();

        // 순수 JDBC 사용
        // return new JdbcMemberRepository(dataSource);

        // 스프링 JDBC 사용
        // return new JdbcTemplateMemberRepository(dataSource);

        // JPA 사용
        return new JpaMemberRepository(em);
    }
}

```

</div>
</details>
<br>

---
## AOP
---
모든 메소도의 호출 시간을 측정하고싶을 때